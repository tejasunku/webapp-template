# Architecture Resources - v0.0
# Configuration notes for external services and platforms

## Hosting Providers

### Render
- **Type**: PaaS for application hosting
- **Purpose**: Main backend services
- **Billing**: Per image served (bundle multiple services per image to save costs)
- **Services**:
  - Backend API (ElysiaJS)
  - Frontend web app
  - Background workers
- **Redis Service**: Redis-compatible, recent enough version for Redis Streams
- **Notes**:
  - Use environment variables for configuration
  - Health checks required for all services
  - Bundle services together when possible to reduce costs

### Supabase
- **Type**: Backend-as-a-Service
- **Purpose**: Managed database and auth
- **Services**:
  - PostgreSQL database (managed)
  - Authentication service (managed)
  - Storage (managed)
  - Edge functions (inactive for now)
- **Notes**:
  - Use Supabase client SDK for connections
  - Database accessed through Supabase client, not direct connections
  - Auth flows handled through Supabase Auth

## Database & Storage

### PostgreSQL (via Supabase)
- **Provider**: Supabase
- **ORM**: Drizzle ORM (v0.30+)
- **Connection**: Through Supabase client
- **Migrations**: Drizzle Kit CLI
- **Driver**: postgres.js (Bun-compatible)

### Storage (via Supabase)
- **Provider**: Supabase Storage
- **Purpose**: File uploads, user assets
- **Access**: Supabase SDK

## Cache & Queue

### Redis (via Render)
- **Provider**: Render Redis
- **Version**: Recent enough for Redis Streams (>5.0)
- **Uses**:
  - Caching layer
  - Redis Streams for job queues
- **Notes**:
  - Same instance for both cache and queues
  - Use different key prefixes to separate concerns
  - Connection managed through environment variables

## Authentication

### Supabase Auth
- **Provider**: Supabase
- **Purpose**: User authentication and session management
- **Integration**: Supabase client SDK
- **Notes**:
  - Handles login/logout flows
  - Token management built-in
  - User roles and permissions

## External APIs

### AI Services (Future)
- **Provider**: OpenRouter (via Vercel AI SDK)
- **Purpose**: AI model integration
- **SDK**: @ai-sdk
- **Validation**: Valibot schemas for structured responses

## Development Environment

### Local Development
- **Method**: Docker Compose
- **Services**:
  - PostgreSQL container
  - Redis container
  - Application containers
- **Runtime**: Bun (≥ 1.1)

### Package Management
- **Tool**: pnpm
- **Monorepo**: pnpm workspaces
- **Bundling**: Vite for frontend, Bun for backend

## Environment Variables

### Required Variables
```bash
# Supabase
SUPABASE_URL=your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key

# Render Redis
REDIS_URL=redis://your-redis-url
REDIS_HOST=your-redis-host
REDIS_PORT=6379
REDIS_PASSWORD=your-redis-password

# Application
NODE_ENV=development
PORT=3000

# AI (Future)
OPENROUTER_API_KEY=your-openrouter-key
```

## Configuration Notes

### Deployment
- All services use environment variables for config
- No hardcoded secrets or URLs
- Validate environment variables at startup with Valibot
- Use different .env files for different environments

### Redis Configuration
- Cache keys: `cache:*`
- Queue streams: `queue:*`
- Session storage: `session:*`
- Rate limiting: `ratelimit:*`

### Database Configuration
- Use connection pooling through Supabase
- Migrations via Drizzle Kit commands
- Schema changes should be backwards compatible
- Use TypeScript types generated by Drizzle

## Service Dependencies

```
ElysiaJS App → Supabase (Auth + DB + Storage)
ElysiaJS App → Redis (Cache + Queue)
Background Workers → Redis (Queue processing)
Frontend → ElysiaJS API
Frontend → Supabase Auth (direct)
```

## Future Resources

### Monitoring (Planned)
- **Provider**: Grafana Cloud
- **Stack**: Loki (logs), Prometheus (metrics), Tempo (traces)
- **Collector**: Grafana Alloy
- **Free Tier**: ~50GB logs, 14-day retention

### CI/CD
- **Platform**: GitHub Actions
- **Triggers**: Push to main, pull requests
- **Tests**: Vitunit, Playwright E2E

## Gotchas & Notes

- Render billing is per image, so bundle services when possible
- Redis on Render can handle both caching and queues via Streams
- Supabase edge functions are available but not using currently
- All external access should go through SDK adapters, not direct calls
- Environment variables must be validated at startup
- Use pnpm workspaces for monorepo package management